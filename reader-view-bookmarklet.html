<!DOCTYPE html>
<html>
<head>
    <title>ðŸ“– Reader View Compatible Bookmarklet</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            line-height: 1.6;
        }
        .bookmarklet {
            background: #007aff;
            color: white;
            padding: 15px 25px;
            border-radius: 8px;
            text-decoration: none;
            font-weight: bold;
            display: inline-block;
            margin: 20px 0;
        }
        .alert {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            color: #856404;
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
        }
        .success {
            background: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
        }
        .info {
            background: #cce7ff;
            border: 1px solid #b3d9ff;
            color: #0066cc;
        }
    </style>
</head>
<body>
    <h1>ðŸ“– Reader View Compatible Bookmarklet</h1>
    
    <div class="alert success">
        <strong>âœ… Reader View Solution!</strong><br>
        This bookmarklet is designed to work with Safari's Reader View by detecting the environment and adapting accordingly.
    </div>
    
    <h3>How It Works</h3>
    <ul>
        <li><strong>Regular Pages:</strong> Extracts content normally</li>
        <li><strong>Reader View:</strong> Uses Safari's cleaned content and gets original URL</li>
        <li><strong>Fallback:</strong> Prompts for manual URL if needed</li>
    </ul>
    
    <h3>Installation</h3>
    <p>Drag this bookmarklet to your Safari bookmarks bar:</p>
    
    <a href="javascript:(function(){
        console.log('ðŸ“– Reader View Compatible Bookmarklet Started');
        
        function showNotification(message, isError = false) {
            const notification = document.createElement('div');
            notification.style.cssText = `position:fixed;top:20px;right:20px;background:${isError ? '#f44336' : '#4CAF50'};color:white;padding:15px 20px;border-radius:8px;z-index:10000;font-family:system-ui;font-size:14px;box-shadow:0 4px 12px rgba(0,0,0,0.3);max-width:300px;`;
            notification.textContent = message;
            document.body.appendChild(notification);
            setTimeout(() => notification.remove(), 4000);
        }
        
        function detectReaderView() {
            return window.location.protocol === 'safari-reader:' || 
                   document.body.classList.contains('safari-reader') ||
                   document.querySelector('body[data-safari-reader]') ||
                   window.location.href.includes('safari-reader://');
        }
        
        function getOriginalURL() {
            // Try to get original URL from various sources
            const metaUrl = document.querySelector('meta[property=\"og:url\"]')?.content ||
                           document.querySelector('meta[name=\"twitter:url\"]')?.content ||
                           document.querySelector('link[rel=\"canonical\"]')?.href;
            
            if (metaUrl) return metaUrl;
            
            // In reader view, sometimes the original URL is in the title
            const titleMatch = document.title.match(/https?:\\/\\/[^\\s]+/);
            if (titleMatch) return titleMatch[0];
            
            // Ask user as fallback
            const userUrl = prompt('ðŸ“– Reader View detected! Please paste the original article URL:', window.location.href);
            return userUrl || window.location.href;
        }
        
        function extractContent() {
            const isReader = detectReaderView();
            console.log('ðŸ” Reader view detected:', isReader);
            
            if (isReader) {
                showNotification('ðŸ“– Reader View detected, adapting...');
                console.log('ðŸ“– Processing reader view content...');
                
                // In reader view, content is usually cleaner
                const titleSelectors = ['h1', '.title', '[class*=title]', '[data-testid*=title]'];
                let title = null;
                
                for (const selector of titleSelectors) {
                    const el = document.querySelector(selector);
                    if (el && el.textContent.trim().length > 3) {
                        title = el.textContent.trim();
                        console.log(`ðŸ“ Found title with selector ${selector}:`, title.substring(0, 50));
                        break;
                    }
                }
                
                if (!title) {
                    title = document.title.replace(/\\s*[-|]\\s*.*$/, '').trim(); // Remove site name
                    console.log('ðŸ“ Fallback to document title:', title.substring(0, 50));
                }
                
                // Better content selection for reader view
                const contentSelectors = [
                    'article',
                    '[role=\"main\"]',
                    '.content',
                    '.article-content',
                    '.post-content',
                    'main',
                    'body'
                ];
                
                let contentEl = null;
                for (const selector of contentSelectors) {
                    const el = document.querySelector(selector);
                    if (el) {
                        console.log(`ðŸ“„ Found content with selector: ${selector}`);
                        contentEl = el;
                        break;
                    }
                }
                
                const content = contentEl ? contentEl.innerHTML : document.body.innerHTML;
                const textContent = contentEl ? contentEl.textContent : document.body.textContent;
                
                console.log('ðŸ“„ Content extraction stats:', {
                    htmlLength: content.length,
                    textLength: textContent.length,
                    selector: contentEl?.tagName + (contentEl?.className ? '.' + contentEl.className : '')
                });
                
                // Get original URL
                const originalUrl = getOriginalURL();
                console.log('ðŸ”— Original URL resolved:', originalUrl);
                
                return {
                    url: originalUrl,
                    title: title,
                    content: content,
                    textContent: textContent.trim(),
                    isReaderView: true
                };
            } else {
                console.log('ðŸŒ Processing regular page content...');
                
                // Only process regular pages if explicitly allowed by user goals
                // For now, we'll skip non-reader pages as per requirements
                console.log('âš ï¸ Non-reader page detected - skipping as per requirements');
                throw new Error('This bookmarklet only works with Reader View pages. Please switch to Reader View first.');
            }
        }
        
        try {
            showNotification('ðŸ”„ Starting article save...');
            console.log('ðŸ“– Reader View Compatible Bookmarklet - Starting extraction');
            
            const extracted = extractContent();
            console.log('ðŸ” Raw extraction result:', {
                url: extracted.url,
                title: extracted.title,
                contentLength: extracted.content?.length || 0,
                textContentLength: extracted.textContent?.length || 0,
                isReaderView: extracted.isReaderView
            });
            
            // Better text cleaning and word counting
            const cleanText = extracted.textContent
                .replace(/\\s+/g, ' ')  // Normalize whitespace
                .replace(/[\\u00A0\\u2000-\\u200B\\u2028-\\u2029\\u202F\\u205F\\u3000]/g, ' ')  // Remove various unicode spaces
                .trim();
            
            console.log('ðŸ§¹ Cleaned text preview:', cleanText.substring(0, 200) + '...');
            
            const wordCount = cleanText.split(/\\s+/).filter(w => w.length > 0).length;
            console.log('ðŸ“Š Word count:', wordCount);
            
            const author = document.querySelector('[class*=author], .byline, [rel=author]')?.textContent || null;
            
            const articleData = {
                url: extracted.url,
                title: extracted.title,
                author: author ? author.trim() : null,
                publishDate: new Date().toISOString(),
                content: extracted.content,
                textContent: cleanText,
                wordCount: wordCount,
                readingTime: Math.ceil(wordCount / 200) * 1000,
                tags: extracted.isReaderView ? 'reader-view' : null
            };
            
            console.log('ðŸ“„ Final article data:', {
                ...articleData,
                content: articleData.content?.substring(0, 100) + '...',
                textContent: articleData.textContent?.substring(0, 100) + '...'
            });
            
            // Validation checks with detailed logging
            if (!articleData.title || articleData.title.length < 3) {
                console.error('âŒ Title validation failed:', articleData.title);
                throw new Error('Could not extract article title');
            }
            
            if (!articleData.textContent || articleData.textContent.length < 50) {
                console.error('âŒ Content validation failed - too short:', articleData.textContent?.length);
                throw new Error('Article content too short to be meaningful');
            }
            
            if (wordCount < 10) {
                console.error('âŒ Word count validation failed:', wordCount);
                throw new Error('Article has too few words');
            }
            
            showNotification('ðŸ“¡ Saving to Reading Tracker...');
            
            // Try HTTPS first, then HTTP
            const endpoints = [
                'https://127.0.0.1:3003/api/articles',
                'http://127.0.0.1:3002/api/articles'
            ];
            
            let saved = false;
            
            for (const endpoint of endpoints) {
                try {
                    console.log(`ðŸ”— Attempting to save via ${endpoint}`);
                    const response = await fetch(endpoint, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(articleData)
                    });
                    
                    console.log(`ðŸ“¡ Response status: ${response.status} ${response.statusText}`);
                    
                    if (response.ok) {
                        const result = await response.json();
                        console.log('âœ… Article saved successfully:', result);
                        showNotification(`âœ… Article saved! ${wordCount} words, ${Math.ceil(wordCount / 200)} min read`);
                        saved = true;
                        break;
                    } else {
                        const errorText = await response.text();
                        console.error(`âŒ Server error (${response.status}):`, errorText);
                    }
                } catch (e) {
                    console.error(`âŒ Failed to save via ${endpoint}:`, e.message);
                    continue;
                }
            }
            
            if (!saved) {
                throw new Error('Could not connect to Reading Tracker API');
            }
            
        } catch (error) {
            console.error('Bookmarklet error:', error);
            showNotification(`âŒ Error: ${error.message}`, true);
        }
    })();" class="bookmarklet">ðŸ“– Save Article (Reader View Compatible)</a>
    
    <h3>Usage Instructions</h3>
    <div class="info">
        <h4>For Regular Web Pages:</h4>
        <ol>
            <li>Visit any article page</li>
            <li>Click the bookmarklet</li>
            <li>Article will be saved automatically</li>
        </ol>
        
        <h4>For Safari Reader View:</h4>
        <ol>
            <li>Open an article and switch to Reader View</li>
            <li>Click the bookmarklet</li>
            <li>If prompted, paste the original article URL</li>
            <li>Article will be saved with cleaned content</li>
        </ol>
    </div>
    
    <h3>Features</h3>
    <ul>
        <li>âœ… <strong>Reader View Detection:</strong> Automatically detects Safari Reader View</li>
        <li>âœ… <strong>URL Recovery:</strong> Finds original article URL from metadata</li>
        <li>âœ… <strong>Clean Content:</strong> Uses Reader View's cleaned content when available</li>
        <li>âœ… <strong>Dual Protocol:</strong> Tries both HTTPS and HTTP APIs</li>
        <li>âœ… <strong>Error Handling:</strong> Clear feedback on success/failure</li>
        <li>âœ… <strong>Tagging:</strong> Marks reader view articles for easy identification</li>
    </ul>
    
    <div class="alert">
        <strong>ðŸ’¡ Pro Tip:</strong> For best results with Reader View, make sure you're on the original article page before switching to Reader View, so the URL metadata is preserved.
    </div>
    
</body>
</html>